#### 软件设计原则
+ 核心原则: 可复用性和可扩展性
+ **原则1:** 封装变化的内容, 将程序中变化和不变的内容分开
  - 方法层面的封装
  ```TypeScript
  // 修改前
  class OrderService {
    public static getOrderTotalPrice(order: Order): number {
      let totalPrice = 0;
      for(const item of order.items) {
        totalPrice += item.price * item.count;
      }
      // 计算增值税
      if (order.country === "CN") {
        totalPrice += totalPrice * 0.13;
      }
      if (order.country === "EU") {
        totalPrice += totalPrice * 0.20;
      }
      return totalPrice;
    }
  }

  // 修改后
  class OrderService {
    public static getOrderTotalPrice(order: Order): number {
      let totalPrice = 0;
      for(const item of order.items) {
        totalPrice += item.price * item.count;
      }
      const taxRate = this.getTaxRateByCountry(order.country);
      return totalPrice + totalPrice * taxRate;
    }

    private static getTaxRateByCountry(country: string): number {  }
  }
  ```
  - 类层面的封装
  ```TypeScript
  class OrderService {
    public static getOrderTotalPrice(order: Order): number {
      let totalPrice = 0;
      for(const item of order.items) {
        totalPrice += item.price * item.count;
      }
      const taxRate = TaxService.getTaxRateByCountry(order.country);
      return totalPrice + totalPrice * taxRate;
    }
  }
  ```
+ **原则2:** 面向接口开发, 依赖抽象类型
```TypeScript
// 修改前, 如果岗位类发生变化, 就必须修改公司类
class Company {
  private designer: Designer = new Designer();
  private programmer: Programmer = new Programmer();
  private tester: Tester = new Tester();

  public createSoftware() {
    this.designer.designArchitecture();
    this.programmer.writeCode();
    this.tester.testSoftware();
  }
}

// 修改1: 面向接口开发, 如果有其他的公司继承该公司类, 但岗位不同, 就会有问题
interface Employee {
  work(): void;
}

class Designer implements Employee {
  public work(): void { /** 设计架构 */ }
}
class Programmer implements Employee {
  public work(): void { /** 编写代码 */ }
}
class Tester implements Employee {
  public work(): void { /** 软件测试 */ }
}

class Company {
  public createSoftware() {
    const employees = [new Designer(), new Programmer(), new Tester()];
    for(const employee of employees) {
      employee.work();
    }
  }
}

// 修改2: 使用抽象方法获取雇员
abstract class Company {
  abstract getEmployees(): Employee[];
  public createSoftware() {
    for(const employee of this.getEmployees()) {
      employee.work();
    }
  }
}

interface CompanyEmployee {
  work(): void;
}
class Designer implements CompanyEmployee {
  public work(): void { /** 设计架构 */ }
}
class Programmer implements CompanyEmployee {
  public work(): void { /** 编写代码 */ }
}
class Tester implements CompanyEmployee {
  public work(): void { /** 软件测试 */ }
}
class UIDesigner implements CompanyEmployee {
  public work(): void { /** UI设计 */ }
}

class GameCompany extends Company {
  public getEmployees(): Employee[] {
    return [new Designer(), new UIDesigner(), new Programmer(), new UIDesigner()]
  } 
}
```
***
**注解:** 这是工厂模式的一个示例
***
+ **原则3:** 组合优于继承
  - 继承的问题: 子类不能减少父类接口; 子类和父类紧密耦合; 子类打破父类的封装
  - 组合是代替继承的方法: 组合强调"有"关系; 继承强调"是"关系
```TypeScript
// 汽车制造, 子类爆炸
class Transport {  }

class Car extends Transport {  }
class ElectricCar extends Transport {  }
class CombustionCar extends Transport {  }
class AutopilotCombustionCar extends CombustionCar {  }
class AutopilotElectricCar extends ElectricCar {  }

class Truck extends Transport {  }
// ...和Car一样, 有电有油, 有手动自动

// 使用组合代替继承
interface Engine {
  start: () => void;
}
interface Driver {
  move: (from: string, to: string) => void;
}

class ElectricEngine implements Engine {  }
class CombustionEngine implements Engine {  }

class MannulDriver implements Driver {  }
class AutoDriver implements Driver {  }

class Transport {
  private engine: Engine = new CombustionEngine();
  private driver: Driver = new MannulDriver();
  public deliver(from: string, to: string) {
    this.engine.start();
    this.driver.move(from, to);
  }
}
```

#### SOLID原则
+ **S:** 单一职责原则, 一个类只做一件事
```TypeScript
// 学生类, 导出的文件类型, 内容格式都可能发生变化
class Student {
  private name: string = "";
  public getName(): string {  }
  public exportStudentDetailInfo(): void {  }
}

// 修改
class ExportService {
  public static exportStudentInfoToExcel(info: StudentInfo): void {  }
}

class Student {
  private name: string = "";
  public getName(): string {  }
  public getDetailInfo(): StudentInfo {  }
  public exportStudentDetailInfo(): void {
    ExportService.exportStudentInfoToExcel(this.getDetailInfo());
  }
}
```
+ **O:** 开闭原则, 对于扩展开放, 对于修改封闭
```TypeScript
class Order {
  // 运费
  public getShippingCost(): number {
    if (this.shipping === "ground") {
      if (this.getTotalWeight() >= 100) {
        return 0;
      }
      return Math.max(10, this.getTotalWeight() * 1.5);
    }
    if (this.shipping === "air") {
      return Math.max(20, this.getTotalWeight() * 3);
    }
  }
}

// 修改
interface Shipping {
  getTotalCost: (weight: number) => number;
}
class GroundShipping implements Shipping {
  public getTotalCost(weight: number): number {
    if (weight >= 100) {
      return 0;
    }
    return Math.max(10, weight * 1.5);
  }
}
class AirShipping implements Shipping {
  public getTotalCost(weight: number): number {
    return Math.max(20, weight * 3);
  }
}

class Order {
  public getShippingCost(): number {
    return this
      .getShippingInstance(this.shipping)
      .getTotalCost(this.getTotalWeight());
  }
}
```
+ **L:** 里氏替换原则, 子类重写父类方法时, 必须和父类行为兼容
```TypeScript
// 情况1: 子类方法的参数类型必须匹配父类方法的参数类型, 或者是其超类
// Banana继承Fuit, Fruit继承Food
class Person {
  public eat(fruit: Fruit): void {  }
}
class Student extends Person {
  public eat(food: Food): void {  }
  // 糟糕的写法
  // public eat(banana: Banana): void {  }
}

// 情况2: 子类方法的返回值类型必须匹配父类方法的返回值类型, 或者是其子类
class Person {
  public buyCat(): Cat {  }
}
class Student extends Person {
  public buyCat(): BengalCat {  }
  // 糟糕的写法
  // public buyCat(): Animal {  }
}
```
***
**注解:** 里氏替换原则的核心, 即将使用父类的地方, 替换为子类, 不能导致程序崩溃
***
+ **I:** 接口隔离原则, 拆分接口细粒度, 类不应该实现不需要的接口
```TypeScript
// 人类不需要冬眠, 但实现Animal接口时必须要实现冬眠方法
interface Animal {
  sleep: () => void;
  eat: () => void;
  hibernate: () => void; // 冬眠
}
class Snake implements Animal { /** 实现接口 */ }
class Human implements Animal { /** 实现接口 */ }

// 修改
interface Animal {
  sleep: () => void;
  eat: () => void;
}
interface Hibernation {
  hibernate: () => void;
}
class Snake implements Animal, Hibernation { /** 实现接口 */ }
class Human implements Animal { /** 实现接口 */ }
```
+ **D:** 依赖倒置原则, 高层类不应该依赖低层类, 二者都应该依赖抽象接口
```TypeScript
class LoginService {
  private sessionService: SessionService = new SessionService();
  public static login(username: string, password: string): void {
    this.sessionService.insertItem("currentUser", username);
    this.sessionService.insertItem("login", "true");
    // ...
  }
}

// 修改
interface BrowserDataStorage {
  intert: (key: string, value: string) => void;
  update: (key: string, value: string) => void;
  getValue: (key: string) => string;
  remove: (key: string) => void;
}

class SessionStorageService extends BrowserDataStorage {  }
class LocalStorageService  extends BrowserDataStorage {  }

class LoginService {
  private browserDataStorage: BrowserDataStorage;
  public static login(username: string, password: string): void {
    this.browserDataStorage.insert("currentUser", username);
    this.browserDataStorage.insert("login", "true");
    // ...
  }
}
```
#### 设计模式
+ 设计模式是在上述软件设计原则的基础上, 构建出的一套软件开发方法
+ 设计模式的分类
  - 创建型设计模式: 用于创建对象, 增加已有代码的灵活性和可复用性
  - 结构型设计模式: 将对象和类组装为较大的结构, 并保持结构的灵活高效
  - 行为型设计模式: 指导对象间的高效沟通, 和职责委派
